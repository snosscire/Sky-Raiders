function DoObjectsCollide( object a, object b ) {
	if( a.bottom <= b.top ) {
		return false;
	}
	if( a.top >= b.bottom ) {
		return false;
	}
	if( a.right <= b.left ) {
		return false;
	}
	if( a.left >= b.right ) {
		return false;
	}
	return true;
}

class Rectangle {
	number x;
	number y;
	number width;
	number height;
	number left;
	number right;
	number top;
	number bottom;
	constructor( number x, number y, number width, number height ) {
		.x = x;
		.y = y;
		.width = width;
		.height = .height;
	}
	function recalculate() {
		.left = .x;
		.right = .x + .width;
		.top = .y;
		.bottom = .y + .height;
	}
}

class Entity {
	static number dt;
	static number sm;
	static function speedMultiplier( number& dt ) {
		if( dt != .dt ) {
			.sm = dt / 10.0;
			.dt = dt;
		}
		return .sm;
	}
	number x;
	number y;
	number speed;
	number angle;
	number left;
	number right;
	number top;
	number bottom;
	number halfWidth;
	number halfHeight;
	object sprite;
	object rotatedSprite;
	
	constructor( string spriteName ) {
		.sprite = Engine.loadImageResource(spriteName);
		.halfWidth = .sprite.width() / 2;
		.halfHeight = .sprite.width() / 2;
	}
	destructor {
		if( .sprite ) {
			Engine.unloadImageResource(.sprite);
		}
	}

	function collide( object o  ) {
		return false;
	}
}

class Player extends Entity {
	number id;
	boolean me;
	string name;
	
	number health;
	number turningSpeed;
	number spriteAngle;
	number lastSpriteAngle;
	boolean stalling;
	
	object controller;
	
	object collisionRectangle;
	
	array smokePuffs;
	number nextSmokePuff;
	
	object deathExplosion;
	
	object weapon;
	boolean shotWeapon;
	
	number sendNextUpdate;
	
	constructor {
		self(Global.PlayerSprite);
		.health = Global.PlayerStartHealth;;
		.stalling = false;
		for( number i = 0; i < Global.PlayerSmokePuffOnScreenAmount; i++ ) {
			.smokePuffs[] = new SmokePuff();
		}
		.deathExplosion = new DeathExplosion();
	}
	
	function update( number deltaTime, object currentMap ) {
		//for( number i = 0; i < Global.PlayerSmokePuffOnScreenAmount; i++ ) {
		//	.smokePuffs[i].update(deltaTime);
		//}
		.weapon and .weapon.update(deltaTime, currentMap);
		if( .health > 0.0 ) {
			number radianAngle;
			number gravityPercentage = 0.0;
			number deltaSpeed;
			
			if( Time.current >= .nextSmokePuff ) {
				for( number i = 0; i < Global.PlayerSmokePuffOnScreenAmount; i++ ) {
					if( .smokePuffs[i].currentLifeTime <= 0 ) {
						.smokePuffs[i].init(.x, .y);
						break;
					}
				}
				.nextSmokePuff = Time.current + Global.PlayerSmokePuffAppearInterval;
			}
			
			.controller and .controller.update(deltaTime);
			
			if( .stalling ) {
				.angle = 90.0;
				if( .spriteAngle >= 80.0 and .spriteAngle <= 100.0 ) {
					.angle = .spriteAngle;
					.stalling = false;
				}
			}

			radianAngle = .angle * Engine.PI180;
			deltaSpeed = (.speed * Entity.speedMultiplier(deltaTime));

			if( /* down */ .angle < 180.0 and .angle > 0 ) {
				number value = 90.0;
				if( .angle < 90.0 ) {
					value = .angle;
				} else if( .angle > 45.0 ) {
					value = 180.0 - .angle;
				}
				gravityPercentage = value / 90.0;
				deltaSpeed = deltaSpeed + ((Global.Gravity * gravityPercentage) * Entity.speedMultiplier(deltaTime));
			} else if( /* up */ .angle > 180.0 and .angle < 360.0 ) {
				number value = 90.0;
				if( .angle < 270.0 ) {
					value = .angle - 180.0;
				} else if( .angle > 270.0 ) {
					value = 360.0 - .angle;
				}
				gravityPercentage = value / 90.0;
				deltaSpeed = deltaSpeed - ((Global.Gravity * gravityPercentage) * Entity.speedMultiplier(deltaTime));
			}

			.x += (deltaSpeed * Engine.cos(radianAngle));
			.y += (deltaSpeed * Engine.sin(radianAngle));
			
			.left = .x - .halfWidth;
			.right = .x + .halfWidth;
			.top = .y - .halfHeight;
			.bottom = .y + .halfHeight;
			
			if( .left <= 0 ) {
				.angle = 180 - .angle;
				.spriteAngle = .angle;
			} else if( .right >= currentMap.getWidth() ) {
				.angle = 180 - .angle;
				.spriteAngle = .angle;
			} /*else if( .top <= 0 ) {
				.angle = 360 - .angle;
			}*/
			
			if( .angle < 0.0 ) {
				.angle += 360.0;
			}
			
			if( .speed <= 0.0 ) {
				.stalling = true;
				.speed = 0.0;
			}
			
			if( .bottom >= currentMap.getHeight() ) {
				.takeDamage(100);
			}
			
			if( .me and (Time.current >= .sendNextUpdate or .shotWeapon) ) {
				Network.send(Network.PlayerUpdateMessage.fromPlayer(self));
				.sendNextUpdate = Time.current + 16;
			}
			
			.shotWeapon = false;
		}
		.deathExplosion.update(deltaTime);
		
		if( .health <= 0.0 and Time.current >= .timeOfDeath + Global.PlayerRespawnTime ) {
			.x = Global.PlayerStartX;
			.y = Global.PlayerStartY;
			.angle = Global.PlayerStartAngle;
			.spriteAngle = Global.PlayerStartAngle;
			.health = Global.PlayerStartHealth;
		}
	}
	
	function draw( object playerCamera, object currentMap ) {
		if( .me or (.x >= playerCamera.left and .x <= playerCamera.right and .y >= playerCamera.top and .y <= playerCamera.bottom) ) {
			//.smokePuffs.each() using ( smokePuff ) {
			//	smokePuff.draw(playerCamera);
			//};
			if( .health > 0.0 ) {
				number x;
				number y;
				object rotatedSprite;
				.weapon and .weapon.draw(playerCamera);
				if( .me ) {
					if( playerCamera.left == 0 or playerCamera.right == currentMap.getWidth() ) {
						x = .x - playerCamera.left;
					} else {
						x = Engine.screenWidth() / 2;
					}
					if( playerCamera.top == 0 || playerCamera.bottom == currentMap.getHeight() ) {
						y = .y - playerCamera.top;
					} else {
						y = Engine.screenHeight() / 2;
					}
				} else {
					x = .x - playerCamera.left;
					y = .y - playerCamera.top;
				}
				if( .rotatedSprite == null or .spriteAngle != .lastSpriteAngle ) {
					.rotatedSprite and .rotatedSprite.unload();
					.rotatedSprite = .sprite.rotate(-(.spriteAngle), 1.0, false);
					.lastSpriteAngle = .spriteAngle;
					Engine.drawImage(.rotatedSprite, x - (.rotatedSprite.width() / 2), y - (.rotatedSprite.height() / 2));
					Engine.loadFont(Global.FontConsole, 10, 10, -2).drawText("${.id}", x, y);
				} else {
					Engine.drawImage(.rotatedSprite, x - (.rotatedSprite.width() / 2), y - (.rotatedSprite.height() / 2));
					Engine.loadFont(Global.FontConsole, 10, 10, -2).drawText("${.id}", x, y);
				}
			}
			.deathExplosion.draw(playerCamera);
		}
	}
	
	function shoot() {
		if( .health > 0.0 ) {
			.weapon.shoot(self);
			.shotWeapon = true;
		}
	}
	function shotWeaponInLastUpdate() {
		return .shotWeapon;
	}
	
	function collisionObject() {
		//return new Rectangle(.x - (.halfWidth), .y - (.halfHeight), .sprite.width(), .sprite.height());
		return self;
	}
	function collide( object o ) {
		if( .health > 0.0 ) {
			return DoObjectsCollide(.collisionObject(), o.collisionObject());
		}
		return false;
	}

	number timeOfDeath;
	function takeDamage( number damage ) {
		.health -= damage;
		if( .health <= 0.0 ) {
			.timeOfDeath = Time.current;
			.deathExplosion.init(.x, .y);
		}
	}
}

class SmokePuff extends Entity {
	number zoom;
	number lifeTime;
	number currentLifeTime;
	constructor {
		self(Global.PlayerSmokePuffSprite);
	}
	function init( number x, number y ) {
		.x = x;
		.y = y;
		.zoom = 1.0;
		.lifeTime = Global.PlayerSmokePuffLifeTime;
		.currentLifeTime = .lifeTime;
	}
	function update( number deltaTime ) {
		if( .currentLifeTime > 0 ) {
			.zoom = (.currentLifeTime + 0.0) / (.lifeTime + 0.0);
			.currentLifeTime -= deltaTime;
		}
	}
	function draw( object playerCamera ) {
		if( .currentLifeTime > 0 ) {
			number x = .x - playerCamera.left;
			number y = .y - playerCamera.top;
			object zoomedImage = .sprite.rotate(0, .zoom, false);
			Engine.drawImage(zoomedImage, x - (zoomedImage.width() / 2), y - (zoomedImage.height() / 2));
			zoomedImage.unload();
		}
	}
}

class ExplosionSmokePuff extends SmokePuff {
	constructor {
		self(Global.PlayerExplosionSmokePuffSprite);
	}
	function init( number x, number y ) {
		number minSpeed;
		number maxSpeed;
		minSpeed = (Global.PlayerExplosionSmokePuffMinSpeed * 1000).round();
		maxSpeed = (Global.PlayerExplosionSmokePuffMaxSpeed * 1000).round();
		.speed = (Number.random(minSpeed, maxSpeed) + 0.0) / 1000;
		.angle = Number.random(0, 360);
		.zoom = 1.0;
		.lifeTime = Global.PlayerExplosionSmokePuffLifeTime;
		.currentLifeTime = .lifeTime;
		.x = x;
		.y = y;
	}
	function update( number deltaTime ) {
		if( .currentLifeTime > 0 ) {
			number radianAngle = .angle * Engine.PI180;
			number deltaSpeed = (.speed * Entity.speedMultiplier(deltaTime));
			.x += (deltaSpeed * Engine.cos(radianAngle));
			.y += (deltaSpeed * Engine.sin(radianAngle));
			.zoom = (.currentLifeTime + 0.0) / (.lifeTime + 0.0);
			.currentLifeTime -= deltaTime;
		}
	}
}

class DeathExplosion extends Entity {
	object sprite;
	number zoom;
	number growTime;
	number shrinkTime;
	number currentGrowTime;
	number currentShrinkTime;
	array smokePuffs;
	constructor {
		.sprite = Engine.loadImageResource(Global.PlayerExplosionSprite);
		for( number i = 0; i < Global.PlayerExplosionSmokePuffAmount; i++ ) {
			.smokePuffs[] = new ExplosionSmokePuff();
		}
	}
	function init( number x, number y ) {
		.x = x;
		.y = y;
		.growTime = Global.PlayerExplosionGrowTime;
		.shrinkTime = Global.PlayerExplosionShrinkTime;
		.currentGrowTime = .growTime;
		.currentShrinkTime = .shrinkTime;
		for( number i = 0; i < Global.PlayerExplosionSmokePuffAmount; i++ ) {
			.smokePuffs[i].init(x, y);
		}
		
	}
	function update( number deltaTime ) {
		for( number i = 0; i < Global.PlayerExplosionSmokePuffAmount; i++ ) {
			.smokePuffs[i].update(deltaTime);
		}
		if( .currentGrowTime > 0 ) {
			.zoom = ((.growTime - .currentGrowTime) + 0.0) / (.growTime + 0.0);
			.currentGrowTime -= deltaTime;
		} else if( .currentShrinkTime > 0 ) {
			.zoom = (.currentShrinkTime + 0.0) / (.shrinkTime + 0.0);
			.currentShrinkTime -= deltaTime;
		}
	}
	function draw( object playerCamera ) {
		if( .currentGrowTime > 0 or .currentShrinkTime > 0 ) {
			number x = .x - playerCamera.left;
			number y = .y - playerCamera.top;
			object zoomedImage = .sprite.rotate(0, .zoom, false);
			Engine.drawImage(zoomedImage, x - (zoomedImage.width() / 2), y - (zoomedImage.height() / 2));
			zoomedImage.unload();
		}
		for( number i = 0; i < Global.PlayerExplosionSmokePuffAmount; i++ ) {
			.smokePuffs[i].draw(playerCamera);
		}
	}
}

