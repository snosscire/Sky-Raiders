class State {
	boolean active;
	boolean listenersRegistered;
	function init();
	function quit();
	function update();
	function draw();
}

class TestState extends State {
	object player;
	object background;
	function init() {
		.player = new Player();
		.player.controller = new KeyboardPlayerController(.player);
		.player.controller.keyLeft = Engine.KEY_LEFT;
		.player.controller.keyRight = Engine.KEY_RIGHT;
		.player.controller.keyShoot = Engine.KEY_s;
		.player.weapon = new MachineGun();
		.player.speed = 1.8;
		.player.turningSpeed = 1.0;
		.player.x = 200;
		.player.y = 100;
		.background = Engine.loadImageResource('background.png');
		.active = true;
		if( not .listenersRegistered ) {
			EventHandler.registerListener(Engine.EVENT_KEYDOWN, self);
		}
	}
	function quit() {
		.active = false;
		.player = null;
		Engine.unloadImageResource(.background);
	}
	function update() {
		//number deltaTime = Time.delta;
		//while( deltaTime > 0 ) {
		//	.player.update(deltaTime);
		//	deltaTime -= 5;
		//}
		.player.update(Time.delta);
	}
	function draw() {
		Engine.drawImage(.background, 0, 0);
		.player.draw();
	}
	function onKeyDown( object event ) {
		if( .active and (not Console.active) ) {
			if( event.key == Engine.KEY_ESCAPE ) {
				Game.setState(Game.menuState());
			}
		}
	}
}

class MultiplayerState extends State {
	object client;
	boolean connected;
	array players;
	object background;
	
	function init() {
		if( not .listenersRegistered ) {
			EventHandler.registerListener(Engine.EVENT_KEYDOWN, self);
			MessageHandler.registerListener(Network.MESSAGE_USER_DISCONNECTED_ME, self);
			MessageHandler.registerListener(Network.MESSAGE_CONNECTION_REFUSED, self);
			MessageHandler.registerListener(Network.MESSAGE_NEW_USER_ME, self);
			MessageHandler.registerListener(Network.MESSAGE_NEW_USER, self);
			.listenersRegistered = true;
		}
		.background = Engine.loadImageResource('background.png');
		.connected = false;
		.active = true;
	}
	function quit() {
		.active = false;
		.connected = false;
		.players = [];
		Network.disconnect();
		Engine.unloadImageResource(.background);
	}
	function update() {
		if( .connected ) {
			//number deltaTime;
			.players.each() using ( player ) {
				player.update(Time.delta);
				//deltaTime = Time.delta;
				//Engine.printLine("Player: ${player.id}, delta time: ${deltaTime}");
				//while( deltaTime > 0 ) {
				//	player.update(deltaTime);
				//	deltaTime -= 5;
				//}
			};
		}
	}
	function draw() {
		if( .connected ) {
			Engine.drawImage(.background, 0, 0);
			.players.each() using ( player ) {
				player.draw();
			};
		}
	}
	
	function onKeyDown( object event ) {
		if( .active and (not Console.active) ) {
			if( event.key == Engine.KEY_ESCAPE ) {
				Game.setState(Game.menuState());
			}
		}
	}
	
	function createPlayer( object message, boolean me ) {
		object player;
		player = new Player();
		player.id = message.id;
		player.name = message.name;
		player.me = me;
		player.speed = 1.8;
		player.turningSpeed = 1.0;
		player.x = 200;
		player.y = 100;

		if( me ) {
			player.controller = new KeyboardPlayerController(player);
			player.controller.keyLeft = Engine.KEY_LEFT;
			player.controller.keyRight = Engine.KEY_RIGHT;
		} else {
			player.controller = new NetworkPlayerController(player);
		}
		
		.players["${message.id}"] = player;
	}
	
	function onConnectionRefused( object message ) {
		string output = 'connection refused... ';
		switch( message.reason ) {
			case Network.CONNECTION_REFUSED_VERSION_MISMATCH:          output += 'version mismatch.'; break;
			case Network.CONNECTION_REFUSED_SERVER_FULL:               output += 'server full.'; break;
			case Network.CONNECTION_REFUSED_SERVER_CLOSED:             output += 'server closed.'; break;
			case Network.CONNECTION_REFUSED_PASSWORD_MISMATCH:         output += 'password mismatch.'; break;
			case Network.CONNECTION_REFUSED_NAME_NOT_UNIQUE:           output += 'name is not unique.'; break;
			case Network.CONNECTION_REFUSED_PROTECTION_KEY_NOT_UNIQUE: output += 'protection key is not unique'; break;
		}
		Console.printLine(output);
	}
	function onUserDisconnectMe( object message ) {
		if( .active ) {
			Game.setState(Game.menuState());
		}
	}
	function onNewUserMe( object message ) {
		if( .active ) {
			//Engine.printLine('onNewUserMe');
			.createPlayer(message, true);
			.connected = true;
		}
	}
	function onNewUser( object message ) {
		if( .active ) {
			//Engine.printLine('onNewUser');
			.createPlayer(message, false);
		}
	}
}

class MenuState extends State {
	object mainMenu;
	object multiplayerMenu;
	object currentMenu;
	function init() {
		object testState = new TestState();
		object font = Engine.loadFont('font-10.png', 10, 10);
		.mainMenu = new Menu();
		.mainMenu.setSelector('Menu/simple-selector.png');
		.mainMenu.addItem(new TextMenuItem(font, "test", closure {
			Game.setState(testState);
		}));
		.mainMenu.addItem(new TextMenuItem(font, "multiplayer", closure {
			Game.setState(Game.multiplayerState());
		}));
		.mainMenu.addItem(new TextMenuItem(font, "options"));
		.mainMenu.addItem(new TextMenuItem(font, "credits"));
		.mainMenu.addItem(new TextMenuItem(font, "quit", closure {
			Game.quit();
		}));
		.mainMenu.active = true;
		.multiplayerMenu = new Menu();
		.currentMenu = .mainMenu;
		.active = true;
		if( not .listenersRegistered ) {
			EventHandler.registerListener(Engine.EVENT_KEYDOWN, self);
			.listenersRegistered = true;
		}
	}
	function quit() {
		.active = false;
		.mainMenu = null;
		.multiplayerMenu = null;
		.currentMenu = null;
	}
	function update() {
		
	}
	function draw() {
		.currentMenu.draw();
	}
	function onKeyDown( object event ) {
		if( .active and (not Console.active) ) {
			if( event.key == Engine.KEY_ESCAPE ) {
				if( .currentMenu == .mainMenu ) {
					Game.quit();
				}
			}
		}
	}
}

