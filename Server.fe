uses 'Global.feh';
uses 'Game/Array.feh';
uses 'Game/String.feh';
uses 'Game/Network_ENet.feh';
uses 'Game/Messages_ENet.feh';

namespace GameServer {
	number nextID = 255;
	array players;
}

class Player {
	object peer;
	number id;
	string name;
	number x;
	number y;
	number angle;
	number spriteAngle;
	number speed;
	number health;
}

function GetNextID() {
	number id = GameServer.nextID;
	GameServer.nextID--;
	return id;
}

function HandleConnect( object server, object connectMessage ) {
	Engine.printLine('User connected - waiting for initialize message...');
}

function HandleDisconnect( object server, object message ) {
	Engine.printLine('User disconnected.');
}

function HandleInitializeJoin( object server, object dataMessage ) {
	object initializeJoinMessage = Network.InitializeJoinMessage.fromData(dataMessage.data, true);
	object newPlayer;
	object newPlayerMessage;
	string newPlayerMessageData;

	Engine.printLine('Initialize Join message recieved - creating player...');
	
	newPlayer = new Player();
	newPlayer.peer = dataMessage.peer;
	newPlayer.id = GetNextID();
	newPlayer.name = initializeJoinMessage.name;
	newPlayer.x = 200;
	newPlayer.y = 100;
	newPlayer.angle = 0;
	newPlayer.spriteAngle = 0;
	newPlayer.speed = 1.8;

	Engine.printLine("Created player ${newPlayer.name} (${newPlayer.id}).");
	
	newPlayerMessage = Network.NewPlayerMessage.fromPlayer(newPlayer);
	newPlayerMessageData = newPlayerMessage.toData();
	
	// Tell the new player that it has joined the game.
	server.send(newPlayer.peer, newPlayerMessageData);
	// Tell the new player about the players that are already connected.
	GameServer.players.each() using ( player ) {
		server.send(newPlayer.peer, Network.NewPlayerMessage.fromPlayer(player).toData());
	};
	// Tell the already connected players that a new player has connected.
	GameServer.players.each() using ( player ) {
		server.send(player.peer, newPlayerMessageData);
	};
	
	GameServer.players["Player/${newPlayer.id}"] = newPlayer;
}

function HandlePlayerUpdate( object server, object dataMessage ) {
	string dataCopy = dataMessage.data;
	object message = Network.PlayerUpdateMessage.fromData(dataMessage.data, true);
	object player = GameServer.players["Player/${message.id}"];
	player.x = message.x;
	player.y = message.y;
	player.angle = message.angle;
	player.spriteAngle = message.spriteAngle;
	player.speed = message.speed;
	player.health = message.health;
	GameServer.players.each() using ( player ) {
		if( player.id != message.id ) {
			server.send(player.peer, dataCopy);
		}
	};
}

function HandleData( object server, object message ) {
	string dataCopy = message.data;
	number type = Network.readByteFromData(dataCopy);
	switch( type ) {
		case Network.MESSAGE_PLAYER_UPDATE:   HandlePlayerUpdate(server, message); break;
		case Network.MESSAGE_INITIALIZE_JOIN: HandleInitializeJoin(server, message); break;
	}
}

number port = Global.ServerDefaultPort;
object server = Network.Server.start(port);

Engine.printLine("Trying to start server at port ${port}...");

if( server ) {
	object message;
	
	Engine.printLine("Server started.");
	
	while( true ) {
		while( message = server.service(1000) ) {
			switch( message.type ) {
				case Network.MESSAGE_CONNECT:    HandleConnect(server, message); break;
				case Network.MESSAGE_DISCONNECT: HandleDisconnect(server, message); break;
				case Network.MESSAGE_DATA:       HandleData(server, message); break;
			}
		}
	}

	server.destroy();
} else {
	Engine.printLine("Error.");
}

